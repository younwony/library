# 요구사항 관련 의사소통

 - 프로그래머와 사업부 사이의 가장 흔한 의사소통 쟁점은 요구사항 이다.
 - 어떤 기능에 대한 고객들의 예상은 컴퓨터로 구현하고 나서 보면 그 예상이 틀린 경우가 많다.

# 시기상조의 정밀도

 - 사업부와 프로그래머는 모두 시기상조의 정밀도(Premature Precision)라는 함정에 빠지기 쉽다.
   - 사업부는 프로젝트 승인 전 일이 어떻게 진행될지 정확히 알고 싶어한다
   - 개발자들은 프로젝트 추정전 어떤 제품을 만들어야 하는지 정확히 알고 싶어한다.
 - 양쪽이 원하는 정밀도는 불가능 하고, 정밀도를 얻기 위해 예산 낭비하는일이 많이 발생한다..

# 불확실성의 원칙

 - 요구사항이 실제 동작하는 모습을 보면 더나은 생각이 떠오르곤 하는데, 그 생각은 대개 구현된 시스템과 많이 다르다.
 - 관찰자 효과라고도 부르는 불확실성의 원칙이 존재한다. 구현된 시스템에서 새로운 정보를 얻고, 그 정보는 전체 시스템을 보는 시각에 영향을 끼친다.
   - 이로인해 요구사항이 정밀해질수록 최종 구현된 시스템과 초기 요구사항의 차이는 더욱 벌어지게 된다.

# 불안한 추정

 - 개발자 역시 정밀도 함정에 빠진다.
 - 개발자는 시스템 구현을 추정해야한다. 그리고 시스템 추정에 정밀도가 필요하다고 생각하지만, 그렇지 안ㅇㅎ다.
   1. 완벽한 정보로 추정을 한다 해도 추정에는 큰 편차가 생기고야 만다.
   2. 불확실성 원칙이 초기 정밀도를 엉망으로 만든다. 요구사항은 반드시 바뀌기 때문에 초기 정밀도는 고려할 가치가 없다.
 - 프로 개발자는 항상 추정에 오차범위를 추가해 사업부에서 불확실성을 이해하게 만든다.

# 때늦은 모호함

 - 시기상조의 정밀도를 해결하기 위해서는 가능한 정밀도를 늦추면 된다.
 - 의견의 불일치를 해결하기 보다는 표현을 바꾸는 방법을 찾아낸다.
 - 요구사항 문서의 모호함은 이해당사자들 간의 논쟁을 대변한다.
 - 요구사항에서 모든 모호함을 제거하는 일은 **프로개발자의책임**이다.

# 인수 테스트

 - 여기서 인수테스트는 '**요구사항이 언제 완료되는지를 정의하기 위해 이해당사자들과 프로그래머들이 힘을 모아 작성하는 테스트**' 로 정의한다.

# '완료'에 대한 정의

 - 프로로써 직면하는 가장 흔한 모호함들 중 하나는 '완료'이다.
 - 프로개발자에게 완료에 대한 정의는 단 하나이다.
   - 모든 코드를 작성
   - 모든 테스트가 통과
   - QA전문가와 이해당사들이 인수
 - 위 기준을 만족하는 자동화 테스트를 만들고 통과하면 된다. **각 기능에 대한 인수테스트를 통과해야만 업무가 완료된다.**

# 의사소통

 - 인수 테스트의 목적은 소통,명확성 및 정밀성이다.
 - 개발자, 이해당사자 및 테스터 모두 동의함으로써 시스템 행동을 위한 계획을 이해한다. 모든 당사들이 이런 명확성 획득에 책임이 있다.
 - 프로 개발자는 모든 당사자들이 무엇을 마들것인가에 대한 인지보장을 위해 이해당사자 및 테스터와 함께 하는 작업에 책임을 진다.

# 자동화

 - 인수 테스트는 언제나 자동화해야 한다.
 - 프로 개발자들은 인수 테스트 자동화의 보장에 책임을 진다.
 - 인수 테스트 자동화를 쉽게 만들어주는 수많은 오픈소스와 상업용 도구들이 있다.
   - FitNesse
   - Cucumber
   - cuke4duke
   - robotframework
   - Selenium

# 추가 작업

 - 인수 테스트의 자동화는 시스템의 명세를 명확히 하는 작업일뿐이다.
   - 세부적인 수준의 명세는 '완료'의 의미를 이해하는 유일한 방법이다.
   - 이해당사자가 구매하는 시스템이 필요한 바를 해 내는지 보장하는 유일한 방법이다.
 - 테스트를 추가 작업으로 보지말고 많은 시간과 비용에 대한 절약으로 보자.
 - 테스트는 잘못된 시스템 구현을 막고 완료한 때를 알게 해준다.

# 누가, 언제 인수 테스트를 작성하는가?

 - 이상적인 경우면 이해당사자와 QA는 테스트의 작성을 돕고, 개발자는 일관성을 검토한다.
 - 현실은 이해당사자는 필요한 세부내역 수준을 확인할 시간도 없고 그렇게 하는 경우도 없다. 그들은 종종 책임을 QA 또는 개발자에게 위임한다.
   - 만약 개발자들이 테스트를 꼭 작성해야 하는 것이라고 한다면, 테스트를 작성하는 개발자들은 테스트를 거친 기능을 실행하는 개발자들과 같지 않다는 점을 유의해야한다.
 - 인수 테스트는 '늦은 정밀성'의 원칙에 따라 보통 기능 구현 며칠 전에 가능한 늦게 작성해야 한다.
 - 애자일 프로젝트에서 테스트는 다음 반복 주기나 전력질주(Sprint)에서 구현할 기능을 선정한 후에 작성한다.
 - 최초의 몇몇 인수 테스트는 반복 주기의 첫째 날에 준비가 되어야 한다.
 - 매일 더 많은 인수 테스트를 완성해서 반복 주기의 중간 지점에는 모든 인수 테스트가 준비돼야 한다.
 - 만일 모든 인수 테스트가 반복 주기의 중간 지점까지 준비가 되지 않으면, 몇몇 개발자는 인수 테스트 작성을 끝내기 위해 속도를 올려야 한다.
   - 이러한 일이 자주 생기면, 그 팀에 더 많은 BA와 QA들을 추가해야 한다.

# 개발자의 역할

 - 기능 구현 작업은 그 기능의 인수 테스트가 준비되면 시작한다.
 - 개발자는 새 기능에 대한 인수 테스트를 실행해서 오류 과정을 살핀다.
 - 위의 과정이 끝나면 인수 테스트를 시스템에 연결하는 작업을 하고 원하는 기능을 실행해 테스트 통과 가정을 시작한다.
 - 개발자의 몫은 시스템에 인수 테스트를 연결한 다음 테스트를 통과 시키는 것이다.

# 테스트 협상과 수동적 공격성

 - 테스트를 만든 사람도 인간이므로 실수를 한다.
 - 프로 개발자는 테스트 저자들이 보다 나은 테스트를 만들도록 협상을 하는 것이다.
   - 결코 하지 말아야 하는 것은 테스트를 맹목적으로 믿는 일이다.

# 인수 테스트와 단위 테스트

 - 인수 테스트는 단위 테스트가 아니다.
 - 단위 테스트
   - 프로그래머가 프로그래머들을 위해 만든다.
   - 코드의 최하위 구조와 행동을 설명하는 공식 디자인 문서이다.
   - 보는 사람은 프로그래머이다.
 - 인수 테스트
   - 사업부를 위해 사업부가 작성한다. (개발자가 마무리를 했더라도.)
   - 사업적 관점에서 시스템이 어떻게 운영되어야 하는지를 구체적으로 표시한 공식 요구사항 문서다.
   - 보는 사람은 사업부와 프로그래머 이다.
 - 단위 및 인수 테스트가 똑같은 사항을 테스트하는 것이 사실이지만, 불필요한 일과는 거리가 멀다.
 - 같은 내용을 테스트할지라도, 다른 메커니즘과 경로를 통해 테스트를 한다.
    - 단위 테스트는 특정 클래스와 메소드를 호출하면서 시스탬 내부로 파고든다.
    - 인수 테스트는 API나 때때로 UI 수준으로 좀 더 외부(원거리)에서 시스템을 호출한다.
    - 따라서 양쪽 테스트의 실행 경로는 매우 다르다.
 - 단위 테스트와 인수 테스트는 첫째가 문서고 둘째가 테스트이다.
 - 테스트의 주 목적은 시스템의 디자인, 구조 및 행동의 공식적인 문서화이다.
 - 테스트가 자동으로 명세하는 디자인, 구조 및 행동을 검증한다는 사실도 쓸모가 있지만, 테스트의 진정한 목적은 사양의 명세이다.

# GUI 및 다른 문제점

 - GUI는 제대로 명세하기 어렵다.
 - '미'라는게 주관적이여서 논란의 여지가 있기 떄문이다.
 - 단일 책임 원칙(SRP, 다른 이유로 바뀌는 것들은 분리하고, 같은 이유로 바뀌는 것들은 함께 모아야 한다)
   - 예로 특정 위치를 기반으로 하여 테스트를 만들기보다는, 버튼의 이름(ID)에 기초에 테스트를 작성하는게 좋다.

# 올바른 인터페이스를 통한 테스트

 - 앞선 SRP에 의거한 방법보다 좋은 방법은 GUI를 통하는 것보다 실제 API를 통해서 기본 시스템의 기능을 불러오는 테스트를 작성하는 것이다.
   - 이 API 는 GUI가 사용하는 API와 같아야 한다.
 - 설계 전문가들은 수십년 동안 업무 규칙(Business Rule)과 GUI를 분리하라고 말해왔다.
 - 단순 GUI만을 테스트하는 것이 아니라면 GUI 바로 아래 위치한 API를 통과하기 위한 업규칙 테스트를 만들어라.
 - GUI의 행동을 명세한 인수 테스트는 GUI와 업무 규칙을 분리해서, GUI를 테스트 하는 동안, 업무 규칙을 스텁(Stup)으로 교체하는것이 좋다.
 - GUI 테스트를 최소한으로 유지해라. 테스트들은 GUI 취약성으로 인해 깨지기 쉽다. GUI 테스트가 늘어날수록 그 테스트를 유지해나갈 가능성은 낮아진다.

# 지속적 통합

